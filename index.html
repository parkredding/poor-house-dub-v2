<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Dub Siren V2 - Browser Test</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            touch-action: manipulation;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            font-size: 1.5em;
            margin: 10px 0;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .start-overlay.hidden {
            display: none;
        }

        .start-btn {
            font-size: 2em;
            padding: 30px 60px;
            background: linear-gradient(145deg, #00ff88, #00cc6a);
            border: none;
            border-radius: 20px;
            color: #1a1a2e;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.4);
        }

        .start-btn:active {
            transform: scale(0.95);
        }

        .start-overlay p {
            margin-top: 20px;
            color: #888;
            text-align: center;
            padding: 0 20px;
        }

        .triggers {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .trigger-btn {
            padding: 30px 10px;
            font-size: 1.3em;
            font-weight: bold;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .trigger-btn:active, .trigger-btn.active {
            transform: scale(0.95);
        }

        .airhorn {
            background: linear-gradient(145deg, #ff6b35, #f7931e);
            color: white;
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.4);
        }

        .airhorn:active, .airhorn.active {
            background: linear-gradient(145deg, #ff8c5a, #ffaa4a);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.6);
        }

        .siren {
            background: linear-gradient(145deg, #e63946, #c1121f);
            color: white;
            box-shadow: 0 8px 25px rgba(230, 57, 70, 0.4);
        }

        .siren:active, .siren.active {
            background: linear-gradient(145deg, #ff5a67, #e63946);
            box-shadow: 0 4px 15px rgba(230, 57, 70, 0.6);
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h2 {
            margin: 0 0 15px 0;
            font-size: 1em;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .control {
            margin-bottom: 15px;
        }

        .control label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.85em;
            color: #aaa;
        }

        .control label span {
            float: right;
            color: #00ff88;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 40px;
            -webkit-appearance: none;
            background: transparent;
            margin: 0;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            background: linear-gradient(145deg, #00ff88, #00cc6a);
            border-radius: 50%;
            margin-top: -11px;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }

        .waveform-select {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .waveform-btn {
            padding: 12px 5px;
            font-size: 0.75em;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .waveform-btn.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
        }

        .visualizer {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .status {
            text-align: center;
            padding: 10px;
            font-size: 0.8em;
            color: #666;
        }

        .status.active {
            color: #00ff88;
        }

        /* Frequency control for manual testing */
        .freq-control {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div class="start-overlay" id="startOverlay">
        <button class="start-btn" id="startBtn">TAP TO START</button>
        <p>iOS requires user interaction to enable audio.<br>Tap the button above to initialize the synthesizer.</p>
    </div>

    <h1>DUB SIREN V2</h1>

    <canvas class="visualizer" id="visualizer"></canvas>

    <div class="triggers">
        <button class="trigger-btn airhorn" id="airhornBtn">AIRHORN</button>
        <button class="trigger-btn siren" id="sirenBtn">SIREN</button>
    </div>

    <div class="section">
        <h2>Oscillator</h2>
        <div class="control">
            <label>Waveform</label>
            <div class="waveform-select" id="oscWaveform">
                <button class="waveform-btn active" data-wave="sine">Sine</button>
                <button class="waveform-btn" data-wave="square">Square</button>
                <button class="waveform-btn" data-wave="sawtooth">Saw</button>
                <button class="waveform-btn" data-wave="triangle">Tri</button>
            </div>
        </div>
        <div class="control freq-control">
            <label>Manual Frequency <span id="freqValue">440</span> Hz</label>
            <input type="range" id="frequency" min="50" max="2000" value="440" step="1">
        </div>
    </div>

    <div class="section">
        <h2>LFO Modulation</h2>
        <div class="control-row">
            <div class="control">
                <label>Rate <span id="lfoRateValue">5.0</span> Hz</label>
                <input type="range" id="lfoRate" min="0.1" max="20" value="5" step="0.1">
            </div>
            <div class="control">
                <label>Depth <span id="lfoDepthValue">0</span>%</label>
                <input type="range" id="lfoDepth" min="0" max="100" value="0" step="1">
            </div>
        </div>
        <div class="control">
            <label>LFO Waveform</label>
            <div class="waveform-select" id="lfoWaveform">
                <button class="waveform-btn active" data-wave="sine">Sine</button>
                <button class="waveform-btn" data-wave="square">Square</button>
                <button class="waveform-btn" data-wave="sawtooth">Saw</button>
                <button class="waveform-btn" data-wave="triangle">Tri</button>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Envelope</h2>
        <div class="control-row">
            <div class="control">
                <label>Attack <span id="attackValue">0.01</span>s</label>
                <input type="range" id="attack" min="0.001" max="1" value="0.01" step="0.001">
            </div>
            <div class="control">
                <label>Release <span id="releaseValue">0.3</span>s</label>
                <input type="range" id="release" min="0.01" max="3" value="0.3" step="0.01">
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Filter</h2>
        <div class="control-row">
            <div class="control">
                <label>Cutoff <span id="filterFreqValue">2000</span> Hz</label>
                <input type="range" id="filterFreq" min="100" max="15000" value="2000" step="10">
            </div>
            <div class="control">
                <label>Resonance <span id="filterResValue">1</span></label>
                <input type="range" id="filterRes" min="0.1" max="20" value="1" step="0.1">
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Delay</h2>
        <div class="control-row">
            <div class="control">
                <label>Time <span id="delayTimeValue">0.3</span>s</label>
                <input type="range" id="delayTime" min="0.05" max="1" value="0.3" step="0.01">
            </div>
            <div class="control">
                <label>Feedback <span id="delayFeedbackValue">30</span>%</label>
                <input type="range" id="delayFeedback" min="0" max="90" value="30" step="1">
            </div>
        </div>
        <div class="control">
            <label>Mix <span id="delayMixValue">0</span>%</label>
            <input type="range" id="delayMix" min="0" max="100" value="0" step="1">
        </div>
    </div>

    <div class="section">
        <h2>Reverb</h2>
        <div class="control-row">
            <div class="control">
                <label>Size <span id="reverbSizeValue">0.5</span></label>
                <input type="range" id="reverbSize" min="0.1" max="1" value="0.5" step="0.01">
            </div>
            <div class="control">
                <label>Mix <span id="reverbMixValue">0</span>%</label>
                <input type="range" id="reverbMix" min="0" max="100" value="0" step="1">
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Master</h2>
        <div class="control">
            <label>Volume <span id="volumeValue">70</span>%</label>
            <input type="range" id="volume" min="0" max="100" value="70" step="1">
        </div>
    </div>

    <div class="status" id="status">Tap "TAP TO START" to initialize audio</div>

    <script>
        // Dub Siren Synthesizer - Web Audio Implementation
        // Simplified architecture for iOS compatibility
        class DubSiren {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.currentNote = null;

                // Preset frequencies
                this.AIRHORN_FREQ = 150;
                this.SIREN_FREQ = 800;

                // Parameters
                this.params = {
                    oscWaveform: 'sine',
                    frequency: 440,
                    lfoRate: 5,
                    lfoDepth: 0,
                    lfoWaveform: 'sine',
                    attack: 0.01,
                    release: 0.3,
                    filterFreq: 2000,
                    filterRes: 1,
                    delayTime: 0.3,
                    delayFeedback: 0.3,
                    delayMix: 0,
                    reverbSize: 0.5,
                    reverbMix: 0,
                    volume: 0.7
                };

                // Persistent nodes (created once in init)
                this.inputGain = null;      // Entry point for oscillators
                this.filter = null;
                this.delay = null;
                this.delayFeedback = null;
                this.delayMix = null;
                this.convolver = null;
                this.reverbMix = null;
                this.masterGain = null;
                this.analyser = null;

                // Per-note nodes (created/destroyed per trigger)
                this.oscillator = null;
                this.lfo = null;
                this.lfoGain = null;
                this.envelope = null;
            }

            async init() {
                try {
                    // Create audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Resume if suspended (iOS requirement)
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    // === BUILD FIXED SIGNAL CHAIN ===
                    // inputGain -> filter -> [dry + delay] -> [dry + reverb] -> master -> analyser -> output

                    // Input gain - oscillators connect here
                    this.inputGain = this.audioContext.createGain();
                    this.inputGain.gain.value = 1;

                    // Filter
                    this.filter = this.audioContext.createBiquadFilter();
                    this.filter.type = 'lowpass';
                    this.filter.frequency.value = this.params.filterFreq;
                    this.filter.Q.value = this.params.filterRes;

                    // Delay with feedback
                    this.delay = this.audioContext.createDelay(2.0);
                    this.delay.delayTime.value = this.params.delayTime;

                    this.delayFeedback = this.audioContext.createGain();
                    this.delayFeedback.gain.value = this.params.delayFeedback;

                    // Delay mix (0 = dry only, 1 = wet only)
                    this.delayMix = this.audioContext.createGain();
                    this.delayMix.gain.value = this.params.delayMix;

                    // Reverb
                    this.convolver = this.audioContext.createConvolver();
                    await this.createReverbIR();

                    this.reverbMix = this.audioContext.createGain();
                    this.reverbMix.gain.value = this.params.reverbMix;

                    // Master output
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.params.volume;

                    // Analyser for visualization
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;

                    // === CONNECT THE CHAIN ===

                    // Input -> Filter
                    this.inputGain.connect(this.filter);

                    // Filter -> Master (dry path)
                    this.filter.connect(this.masterGain);

                    // Filter -> Delay -> DelayMix -> Master (delay wet path)
                    this.filter.connect(this.delay);
                    this.delay.connect(this.delayMix);
                    this.delayMix.connect(this.masterGain);

                    // Delay feedback loop
                    this.delay.connect(this.delayFeedback);
                    this.delayFeedback.connect(this.delay);

                    // Filter -> Convolver -> ReverbMix -> Master (reverb wet path)
                    this.filter.connect(this.convolver);
                    this.convolver.connect(this.reverbMix);
                    this.reverbMix.connect(this.masterGain);

                    // Master -> Analyser -> Output
                    this.masterGain.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);

                    console.log('Audio initialized successfully');
                    return true;
                } catch (e) {
                    console.error('Audio init failed:', e);
                    this.updateStatus('Audio init failed: ' + e.message);
                    return false;
                }
            }

            async createReverbIR() {
                // Create impulse response for reverb
                const sampleRate = this.audioContext.sampleRate;
                const length = Math.max(sampleRate * this.params.reverbSize * 2, sampleRate * 0.5);
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.exp(-4 * i / length);
                        channelData[i] = (Math.random() * 2 - 1) * decay;
                    }
                }

                this.convolver.buffer = impulse;
            }

            trigger(frequency, type = 'custom') {
                if (!this.audioContext) {
                    console.error('No audio context');
                    return;
                }

                // Resume context if needed (iOS can suspend it)
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                // Stop any existing note cleanly
                this.stopOscillators();

                const now = this.audioContext.currentTime;

                // Create oscillator
                this.oscillator = this.audioContext.createOscillator();
                this.oscillator.type = this.params.oscWaveform;
                this.oscillator.frequency.value = frequency;

                // Create LFO for frequency modulation
                this.lfo = this.audioContext.createOscillator();
                this.lfo.type = this.params.lfoWaveform;
                this.lfo.frequency.value = this.params.lfoRate;

                this.lfoGain = this.audioContext.createGain();
                this.lfoGain.gain.value = frequency * (this.params.lfoDepth / 100);

                // Connect LFO to oscillator frequency
                this.lfo.connect(this.lfoGain);
                this.lfoGain.connect(this.oscillator.frequency);

                // Create envelope
                this.envelope = this.audioContext.createGain();
                this.envelope.gain.setValueAtTime(0.0001, now);
                this.envelope.gain.exponentialRampToValueAtTime(1, now + Math.max(this.params.attack, 0.001));

                // Connect: oscillator -> envelope -> inputGain (which feeds the fixed chain)
                this.oscillator.connect(this.envelope);
                this.envelope.connect(this.inputGain);

                // Start oscillators
                this.oscillator.start(now);
                this.lfo.start(now);

                this.isPlaying = true;
                this.currentNote = { type, frequency };

                this.updateStatus(`Playing: ${type} @ ${frequency}Hz`);
                console.log(`Triggered ${type} at ${frequency}Hz`);
            }

            stopOscillators() {
                const now = this.audioContext ? this.audioContext.currentTime : 0;

                if (this.oscillator) {
                    try {
                        this.oscillator.stop(now);
                        this.oscillator.disconnect();
                    } catch (e) { /* already stopped */ }
                    this.oscillator = null;
                }

                if (this.lfo) {
                    try {
                        this.lfo.stop(now);
                        this.lfo.disconnect();
                    } catch (e) { /* already stopped */ }
                    this.lfo = null;
                }

                if (this.lfoGain) {
                    try { this.lfoGain.disconnect(); } catch (e) {}
                    this.lfoGain = null;
                }

                if (this.envelope) {
                    try { this.envelope.disconnect(); } catch (e) {}
                    this.envelope = null;
                }
            }

            release() {
                if (!this.audioContext || !this.envelope) return;

                const now = this.audioContext.currentTime;
                const releaseTime = Math.max(this.params.release, 0.01);

                // Smooth release envelope
                this.envelope.gain.cancelScheduledValues(now);
                this.envelope.gain.setValueAtTime(this.envelope.gain.value, now);
                this.envelope.gain.exponentialRampToValueAtTime(0.0001, now + releaseTime);

                // Schedule stop after release completes
                const stopTime = now + releaseTime + 0.05;

                if (this.oscillator) {
                    this.oscillator.stop(stopTime);
                }
                if (this.lfo) {
                    this.lfo.stop(stopTime);
                }

                this.isPlaying = false;
                this.currentNote = null;

                // Clean up references after stop
                setTimeout(() => {
                    this.oscillator = null;
                    this.lfo = null;
                    this.lfoGain = null;
                    this.envelope = null;
                    if (!this.isPlaying) {
                        this.updateStatus('Ready');
                    }
                }, (releaseTime + 0.1) * 1000);
            }

            triggerAirhorn() {
                this.trigger(this.AIRHORN_FREQ, 'Airhorn');
            }

            triggerSiren() {
                this.trigger(this.SIREN_FREQ, 'Siren');
            }

            setParam(name, value) {
                this.params[name] = value;

                // Update live nodes
                switch (name) {
                    case 'filterFreq':
                        if (this.filter) this.filter.frequency.value = value;
                        break;
                    case 'filterRes':
                        if (this.filter) this.filter.Q.value = value;
                        break;
                    case 'delayTime':
                        if (this.delay) this.delay.delayTime.value = value;
                        break;
                    case 'delayFeedback':
                        if (this.delayFeedback) this.delayFeedback.gain.value = value;
                        break;
                    case 'delayMix':
                        if (this.delayMix) this.delayMix.gain.value = value;
                        break;
                    case 'reverbMix':
                        if (this.reverbMix) this.reverbMix.gain.value = value;
                        break;
                    case 'reverbSize':
                        this.createReverbIR();
                        break;
                    case 'volume':
                        if (this.masterGain) this.masterGain.gain.value = value;
                        break;
                    case 'lfoRate':
                        if (this.lfo) this.lfo.frequency.value = value;
                        break;
                    case 'lfoDepth':
                        if (this.lfoGain && this.currentNote) {
                            this.lfoGain.gain.value = this.currentNote.frequency * (value / 100);
                        }
                        break;
                    case 'oscWaveform':
                        if (this.oscillator) this.oscillator.type = value;
                        break;
                    case 'lfoWaveform':
                        if (this.lfo) this.lfo.type = value;
                        break;
                }
            }

            updateStatus(text) {
                const status = document.getElementById('status');
                if (status) {
                    status.textContent = text;
                    status.className = 'status' + (this.isPlaying ? ' active' : '');
                }
            }

            getAnalyserData() {
                if (!this.analyser) return null;
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteTimeDomainData(dataArray);
                return dataArray;
            }
        }

        // Initialize
        const siren = new DubSiren();
        let visualizerAnimationId = null;

        // Start button handler
        document.getElementById('startBtn').addEventListener('click', async () => {
            const success = await siren.init();
            if (success) {
                document.getElementById('startOverlay').classList.add('hidden');
                document.getElementById('status').textContent = 'Ready - Tap AIRHORN or SIREN';
                startVisualizer();
            }
        });

        // Trigger buttons
        const airhornBtn = document.getElementById('airhornBtn');
        const sirenBtn = document.getElementById('sirenBtn');

        // Touch and mouse events for triggers
        function addTriggerEvents(btn, triggerFn) {
            let isDown = false;

            const start = (e) => {
                e.preventDefault();
                if (!isDown) {
                    isDown = true;
                    btn.classList.add('active');
                    triggerFn();
                }
            };

            const end = (e) => {
                e.preventDefault();
                if (isDown) {
                    isDown = false;
                    btn.classList.remove('active');
                    siren.release();
                }
            };

            btn.addEventListener('touchstart', start, { passive: false });
            btn.addEventListener('touchend', end, { passive: false });
            btn.addEventListener('touchcancel', end, { passive: false });
            btn.addEventListener('mousedown', start);
            btn.addEventListener('mouseup', end);
            btn.addEventListener('mouseleave', end);
        }

        addTriggerEvents(airhornBtn, () => siren.triggerAirhorn());
        addTriggerEvents(sirenBtn, () => siren.triggerSiren());

        // Manual frequency trigger
        const freqSlider = document.getElementById('frequency');
        freqSlider.addEventListener('input', (e) => {
            document.getElementById('freqValue').textContent = e.target.value;
        });

        // Double tap frequency slider to trigger at that frequency
        let lastFreqTap = 0;
        freqSlider.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastFreqTap < 300) {
                siren.trigger(parseInt(freqSlider.value), 'Manual');
                setTimeout(() => siren.release(), 500);
            }
            lastFreqTap = now;
        });

        // Slider controls
        const sliderMappings = [
            { id: 'lfoRate', param: 'lfoRate', display: 'lfoRateValue', format: v => v.toFixed(1) },
            { id: 'lfoDepth', param: 'lfoDepth', display: 'lfoDepthValue', format: v => Math.round(v) },
            { id: 'attack', param: 'attack', display: 'attackValue', format: v => v.toFixed(2) },
            { id: 'release', param: 'release', display: 'releaseValue', format: v => v.toFixed(2) },
            { id: 'filterFreq', param: 'filterFreq', display: 'filterFreqValue', format: v => Math.round(v) },
            { id: 'filterRes', param: 'filterRes', display: 'filterResValue', format: v => v.toFixed(1) },
            { id: 'delayTime', param: 'delayTime', display: 'delayTimeValue', format: v => v.toFixed(2) },
            { id: 'delayFeedback', param: 'delayFeedback', display: 'delayFeedbackValue', format: v => Math.round(v), scale: 0.01 },
            { id: 'delayMix', param: 'delayMix', display: 'delayMixValue', format: v => Math.round(v * 100), scale: 0.01 },
            { id: 'reverbSize', param: 'reverbSize', display: 'reverbSizeValue', format: v => v.toFixed(2) },
            { id: 'reverbMix', param: 'reverbMix', display: 'reverbMixValue', format: v => Math.round(v * 100), scale: 0.01 },
            { id: 'volume', param: 'volume', display: 'volumeValue', format: v => Math.round(v * 100), scale: 0.01 },
        ];

        sliderMappings.forEach(mapping => {
            const slider = document.getElementById(mapping.id);
            if (slider) {
                slider.addEventListener('input', (e) => {
                    let value = parseFloat(e.target.value);
                    const scaledValue = mapping.scale ? value * mapping.scale : value;
                    siren.setParam(mapping.param, scaledValue);
                    document.getElementById(mapping.display).textContent = mapping.format(scaledValue);
                });
            }
        });

        // Waveform selectors
        function setupWaveformSelector(containerId, param) {
            const container = document.getElementById(containerId);
            const buttons = container.querySelectorAll('.waveform-btn');

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    siren.setParam(param, btn.dataset.wave);
                });
            });
        }

        setupWaveformSelector('oscWaveform', 'oscWaveform');
        setupWaveformSelector('lfoWaveform', 'lfoWaveform');

        // Visualizer
        function startVisualizer() {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            const resize = () => {
                canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            };
            resize();
            window.addEventListener('resize', resize);

            function draw() {
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;

                // Clear
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, width, height);

                // Get waveform data
                const dataArray = siren.getAnalyserData();
                if (!dataArray) {
                    visualizerAnimationId = requestAnimationFrame(draw);
                    return;
                }

                // Draw waveform
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00ff88';
                ctx.beginPath();

                const sliceWidth = width / dataArray.length;
                let x = 0;

                for (let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = (v * height) / 2;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // Add glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ff88';

                visualizerAnimationId = requestAnimationFrame(draw);
            }

            draw();
        }

        // Prevent zoom on double tap
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });

        let lastTouchEnd = 0;

        // Handle page visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && siren.isPlaying) {
                siren.release();
            }
        });
    </script>
</body>
</html>
